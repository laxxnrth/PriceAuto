import streamlit as st
import polars as pl
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from lib_predicteur import meilleures_voitures


@st.cache_data
def load_data():
    return pl.read_json("annonces.json")


@st.cache_resource
def load_meilleures_voitures(boite: str):
    best_voitures = meilleures_voitures("annonces.json", boite)
    return best_voitures


st.set_page_config(page_title="PriceAuto")
st.title("PriceAuto ‚úîÔ∏è‚Äã")

df = load_data()

couleur = sns.color_palette("Blues_d")[1]

def Accueil():
    st.markdown(
        """
        Le march√© des voitures d'occasion est extr√™mement vaste et diversifi√©, avec des prix influenc√©s par un grand nombre de facteurs, tels que le kilom√©trage, l'ann√©e de fabrication,
        le mod√®le ou m√™me le type de bo√Æte. Les prix des voitures d'occasion sont souvent difficiles √† estimer de mani√®re exacte, car ils d√©pendent de caract√©risitiques internes (comme l'√©tat 
        de la voiture) et externes (comme la demande locale).

        Dans ce contexte, il peut √™tre difficile pour un acheteur ou un vendeur de savoir si le prix demand√© pour une voiture est **correct** ou si la voiture est 
        **sous-√©valu√©e** ou **sur-√©valu√©e** par rapport √† sa valeur r√©elle sur le march√©.

        ### Objectif üéØ‚Äã

        L'objectif principal de ce projet est d'utiliser des mod√®les de Machine Learning pour pr√©dire le prix d'une voiture en fonction de plusieurs caract√©ristiques mesurables,
        puis de comparer ce **prix pr√©dit** avec le **prix r√©el** sur le march√©.

        L'id√©e est d'identifier les voitures pour lesquelles le prix r√©el est significativement plus bas que le prix pr√©dit, ce qui peut indiquer que ces voitures sont sous-√©valu√©es  et 
        repr√©sentent une bonne affaire pour un acheteur potentiel.

        ### Sp√©cificit√© de la bo√Æte de vitesse ‚öôÔ∏è

        La bo√Æte **manuelle** et la bo√Æte **automatique** peuvent √™tre per√ßues diff√©remment par les consommateurs. \n
        Dans de nombreux march√©s, les voitures √† bo√Æte automatique sont g√©n√©ralement consid√©r√©es comme plus confortables et modernes, ce qui peut entra√Æner
        des prix plus plus √©lev√©s, en particulier sur des mod√®les r√©cents. Les voitures √† bo√Æte manuelle, quant √† elles, peuvent √™tre moins populaires dans certaines r√©gions
        et peuvent √™tre source d'une demande plus faible dans d'autres march√©s. Cela peut donc influencer le prix de mani√®re diff√©rente.

        Afin de prendre en compte l'h√©t√©rogeneit√© des tranches de prix pour les voitures √† bo√Æte manuelle et celles des voitures √† bo√Æte automatique, nous vous permettons
        de pr√©dire les prix des voitures selon ces deux types de bo√Æte de vitesse.

        ### Pr√©sentation de l'application üì±

        Cette application *Streamlit* vous permet dans un premier temps de visualiser les donn√©es r√©colt√©es suite au Web Scraping dans l'onglet "*Donn√©es des voitures*".
        Vous pouvez jeter un coup d'oeil √† l'int√©gralit√© des donn√©es √† notre disposition, mais nous vous offrons √©galement la possibilit√© de
        visualiser les graphiques de distribution des voitures selon diff√©rentes cat√©gories. \n 
        
        L'onglet "*Flitrer les voitures*" vous permet d'effectuer des recherches selon la tranche de prix qui vous int√©resse, vous offrant ainsi la possibilit√© d'aller 
        sur la page d'annonce de vente de la voiture (*R√©f√©rence*) qui correspond le mieux √† votre budget.

        L'onglet "*Pr√©diction du prix*" renvoie les 5 voitures dont le prix r√©el est minimis√© par rapport au prix pr√©dit selon le type de bo√Æte de vitesse, qui 
        constituent donc les principales voitures sous-√©valu√©es sur le march√© des voitures d'occasion. 

        ##### ... üöó **Nous vous laissons d√©couvrir cette application en toute s√©r√©nit√© !**

        """
    )


def Donnees():
    st.subheader("Donn√©es des voitures üìà")
    st.markdown(
        """ 
        Les donn√©es des voitures ont √©t√© r√©colt√©es gr√¢ce au *Web Scraping*, une technique d'extraction automatique des donn√©es de sites web.
        Nous nous sommes bas√©s sur le site [**Autosph√®re**](https://www.autosphere.fr/), premier distributeur d'automobiles en France, 
        mettant en vente plus de 15 000 voitures neuves et d'occasion.

        Pour chaque voiture, nous avons les caract√©ristiques suivantes : 
        * Le **nom**,
        * La **marque**,
        * Le **mod√®le**,
        * La **puissance** r√©elle en chevaux,
        * L'**√©nergie**,
        * L'**ann√©e** de fabrication,
        * Le **kilom√®trage**,
        * Le type de **bo√Æte** de vitesse,
        * Le **prix** en euros,
        * La **mensualit√©** minimale propos√©e pour payer en plusieurs fois,
        * La **localisation** de vente gr√¢ce au code postal,
        * La **proximit√©** ou non avec la r√©gion d'√éle-de-France.

        Nous vous laissons jeter un coup d'oeil aux donn√©es gr√¢ce au tableau int√©ractif ci-dessous. ‚¨áÔ∏è‚Äã

        """
    )

    df_sans_ref = df.drop("R√©f√©rence")
    st.write(df_sans_ref)

    st.markdown(
        """ 
        Afin de pr√©senter au mieux les donn√©es, voici les distributions des voitures selon 5 cat√©gories :

        """
    )

    option = st.radio(
        "",
        ("Marque", "Boite", "Energie", "Prix", "Kilom√©trage"),
    )

    if option == "Marque":

        marques_count = df.group_by("Marque").agg(pl.len().alias("Nombre de voitures"))
        marques_count_sorted = marques_count.sort("Nombre de voitures", descending=True)

        top_10_marques = marques_count_sorted.head(10)
        top_10_marques_pandas = top_10_marques.to_pandas()

        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(
            x="Marque",
            y="Nombre de voitures",
            data=top_10_marques_pandas,
            ax=ax,
            palette="Blues_d",
        )
        for bar in ax.patches:
            bar.set_edgecolor("white")

        ax.set_ylabel(" ")
        ax.set_xlabel(" ")
        ax.tick_params(axis="x")
        ax.tick_params(axis="y")
        ax.set_title(
            "Top 10 des marques de voitures les plus pr√©sentes en nombre de voitures"
        )
        ax.tick_params(axis="y")

        st.pyplot(fig)

    elif option == "Boite":

        boite_count = df.group_by("Boite").agg(pl.len().alias("Nombre de voitures"))
        boite_count_sorted = boite_count.sort("Nombre de voitures", descending=True)

        type_boite = boite_count_sorted.head(10)
        type_boite_pandas = type_boite.to_pandas()

        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(
            x="Boite",
            y="Nombre de voitures",
            data=type_boite_pandas,
            ax=ax,
            palette="Blues_d",
            width=0.3,
        )
        for bar in ax.patches:
            bar.set_edgecolor("white")

        ax.set_ylabel(" ")
        ax.set_xlabel(" ")
        ax.tick_params(axis="x")
        ax.tick_params(axis="y")
        ax.set_title(
            "Distribution des voitures selon le type de bo√Æte de vitesse en nombre de voitures"
        )
        ax.tick_params(axis="y")

        st.pyplot(fig)

    elif option == "Energie":

        energie_count = df.group_by("Energie").agg(pl.len().alias("Nombre de voitures"))

        energie_count_sorted = energie_count.sort("Nombre de voitures", descending=True)

        energie_count_sorted_pd = energie_count_sorted.to_pandas()

        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(
            x="Energie",
            y="Nombre de voitures",
            data=energie_count_sorted_pd,
            ax=ax,
            palette="Blues_d",
        )

        for bar in ax.patches:
            bar.set_edgecolor("white")

        ax.set_xlabel(" ")
        ax.set_ylabel(" ")
        ax.set_title("Distribution des Energies en nombre de voitures")
        ax.tick_params(axis="x")
        ax.tick_params(axis="y")

        st.pyplot(fig)

    if option == "Prix":
        fig, ax = plt.subplots(figsize=(12, 8))
        prix_df = df.select("Prix")
        prix_pandas = prix_df.to_pandas()

        sns.histplot(prix_pandas, ax=ax, color=couleur, bins=100)
        ax.set_xlim(0, 125000)
        ax.legend().set_visible(False)

        ax.set_xlabel("Prix (‚Ç¨)")
        ax.set_ylabel(" ")
        ax.tick_params(axis="x")
        ax.tick_params(axis="y")
        ax.set_title(
            "Distribution des Prix des Voitures en nombre de voitures"
        )

        for bar in ax.patches:
            bar.set_edgecolor("white")
            bar.set_facecolor(couleur)

        st.pyplot(fig)

    if option == "Kilom√©trage":
        fig, ax = plt.subplots(figsize=(12, 8))
        kilometre_df = df.select("Kilom√®tre")
        kilometre_pandas = kilometre_df.to_pandas()

        sns.histplot(kilometre_pandas, ax=ax, color=couleur, bins=75)
        ax.set_xlim(0, 125000)
        ax.legend().set_visible(False)

        ax.set_xlabel("Kilom√©trage (km)")
        ax.set_ylabel(" ")
        ax.tick_params(axis="x")
        ax.tick_params(axis="y")

        for bar in ax.patches:
            bar.set_edgecolor("white")
            bar.set_facecolor(couleur)

        ax.set_title(
            "Distribution des Kilom√©trages des Voitures en nombre de voitures"
        )

        st.pyplot(fig)

    st.markdown(
        """ 
        *Nous tenons √† rappeler que ces donn√©es sont utilis√©es √† des fins p√©dagogiques dans le cadre d'un projet universitaire. 
        Toute utilisation √† des fins commerciales est strictement interdite.*
        """
    )

    st.sidebar.markdown("Donn√©es des voitures")


def Filtrer():
    st.subheader("Filtrer les voitures üîç‚Äã")

    st.write(
        f""" 

        Nous savons √† quel point l'achat d'une voiture peut √™tre une d√©cision importante et parfois difficile, 
        surtout lorsqu'on prend en compte la diversit√© des mod√®les, des marques, et des crit√®res comme l'√¢ge, le kilom√©trage, 
        ou encore le type de bo√Æte de vitesse. Ajoutez √† cela le facteur prix, et cela peut rapidement devenir un vrai casse-t√™te.

        C'est pourquoi cette page a √©t√© sp√©cialement con√ßue pour vous permettre de **filtrer les voitures selon une tranche de prix adapt√©e √† votre budget**. 
        Gr√¢ce √† cet outil, vous pourrez explorer les options qui vous correspondent le mieux et √©viter de perdre du temps avec des voitures qui d√©passent votre budget.

        **Les informations cl√©s sur les prix des voitures disponibles :**

        - Le prix **minimal** des voitures pr√©sentes dans notre base de donn√©es est de *{df["Prix"].min()} ‚Ç¨*.
        - Le prix **maximum** s'√©l√®ve √† *{df["Prix"].max()} ‚Ç¨*, offrant ainsi une large gamme de v√©hicules, du plus abordable au plus premium.
        - Le prix **moyen** des voitures disponibles est de *{round(df['Prix'].mean())} ‚Ç¨*, ce qui vous donne une bonne id√©e de la gamme de prix g√©n√©rale.
        - Enfin, le prix **m√©dian**, c'est-√†-dire celui qui s√©pare la moiti√© des voitures moins ch√®res de l'autre moiti√©, est de *{round(df['Prix'].median())} ‚Ç¨*. 
        Cela peut √™tre un bon indicateur du prix central, loin des extr√™mes.

        Gr√¢ce √† ces donn√©es, vous pourrez ajuster vos attentes en fonction du budget que vous souhaitez investir √† votre achat et facilement 
        trouver une voiture qui correspond √† vos crit√®res financiers.

        Maintenant, vous pouvez utiliser le filtre de prix ci-dessous pour affiner votre recherche en fonction de votre budget et 
        d√©couvrir les voitures qui vous conviennent le mieux !

        """
    )

    min_prix, max_prix = df["Prix"].min(), df["Prix"].max()
    prix = st.slider(
        "Choisissez une plage de prix",
        min_value=min_prix,
        max_value=max_prix,
        value=(min_prix, max_prix),
        step=10,
    )

    filtered_data = df.filter((df["Prix"] >= prix[0]) & (df["Prix"] <= prix[1]))

    columns = [col for col in filtered_data.columns if col != "R√©f√©rence"] + [
        "R√©f√©rence"
    ]
    filtered_data = filtered_data.select(columns)
    filtered_data_pandas = filtered_data.to_pandas()

    st.dataframe(
        filtered_data_pandas.style.hide(axis="index"),
        use_container_width=True,
    )

    st.sidebar.markdown("Filtrer les voitures")


def Predictions():
    st.subheader("Pr√©dictions de prix üí∏‚Äã")

    st.markdown(
        """
        Sur cette page, nous mettons √† votre disposition une s√©lection de 5 voitures dont le prix r√©el est **minimis√© par rapport au prix pr√©dit** 
        par notre mod√®le. Cela vous permet de d√©couvrir les voitures qui, selon notre algorithme, offrent un bon rapport qualit√©-prix en termes de prix r√©el et estim√©.

        **Les variables cl√©s utilis√©es pour l'entra√Ænement de nos mod√®les de pr√©diction sont les suivantes :**
    
        - **Mensualit√© minimale** propos√©e pour un paiement en plusieurs fois, permettant de visualiser l'importance du prix total de la voiture.
        - **Kilom√©trage** de la voiture, un facteur essentiel pour estimer l'usure et la valeur restante du v√©hicule.
        - **Puissance** en chevaux, qui impacte non seulement la performance de la voiture mais aussi son prix de march√©.
        - **Ann√©e de mise en circulation**, influen√ßant la d√©pr√©ciation du v√©hicule et sa valeur estim√©e.
        - **Appartenance √† la r√©gion √éle-de-France** ou non, un crit√®re qui peut jouer sur la valeur des voitures en fonction de la demande et de l'offre locale.

        Ces variables sont combin√©es dans nos **mod√®les de Machine Learning** pour effectuer des pr√©dictions aussi pr√©cises que possible sur le prix des voitures. 
        Nous avons utilis√© plusieurs techniques pour entra√Æner nos mod√®les, et voici les principaux :

        - **For√™t Al√©atoire (Random Forest)** : un mod√®le puissant qui apprend √† partir de multiples arbres d√©cisionnels pour fournir des pr√©dictions robustes.
        - **K-Nearest Neighbors (KNN)** : un mod√®le qui se base sur la similarit√© des voitures pour pr√©dire les prix en fonction des voisins les plus proches.
        - **R√©gression Lin√©aire** : un mod√®le plus simple, mais efficace, qui cherche √† √©tablir une relation lin√©aire entre les variables ind√©pendantes et le prix.
        - **Support Vector Machines (SVM)** : un mod√®le qui maximise la marge entre les diff√©rentes classes de donn√©es pour am√©liorer la pr√©cision des pr√©dictions.

        Le **choix du meilleur mod√®le de pr√©diction** repose sur deux crit√®res fondamentaux : la *performance sur les donn√©es d'entra√Ænement* et 
        l'*absence de surapprentissage* (ou overfitting). Nous avons ainsi s√©lectionn√© le mod√®le offrant la meilleure g√©n√©ralisation, c'est-√†-dire 
        celui qui pr√©dit le mieux sur des donn√©es non vues, sans √™tre trop sp√©cifique aux donn√©es d'entra√Ænement.

        **D√©couvrez d√®s maintenant les r√©sultats en choisissant le type de bo√Æte de vitesse !**
        """
    )

    boite = st.selectbox("Choisissez le type de bo√Æte", ["Manuelle", "Automatique"])

    if st.button("Afficher les meilleures voitures"):

        liste_voitures = load_meilleures_voitures(boite)

        indices_voitures = liste_voitures[1]

        data = pd.read_json("annonces.json")
        voitures_affichage = []

        for i in indices_voitures:
            voiture = data.loc[
                i,
                [
                    "Nom",
                    "Prix",
                    "Mensualit√©",
                    "Puissance",
                    "Energie",
                    "Kilom√®tre",
                    "Ann√©e",
                    "Localisation",
                    "R√©f√©rence",
                ],
            ]
            voitures_affichage.append(voiture)

        df_voitures = pd.DataFrame(voitures_affichage)

        st.write(df_voitures.drop_duplicates())

    st.sidebar.markdown("Pr√©diction des prix")


page_names_to_funcs = {
    "Accueil": Accueil,
    "Donn√©es des voitures": Donnees,
    "Filtrer les voitures": Filtrer,
    "Pr√©diction du prix": Predictions,
}

selected_page = st.sidebar.selectbox("Choisis une page", page_names_to_funcs.keys())
page_names_to_funcs[selected_page]()
